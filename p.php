<?php
//for Props (i.e. a system comprises of props), there are master and slave systems (thus enabling for a network of systems to have direction)
  //master as an asymptotic limit 0->1 for all systems, so some systems fall behind as being functional for others while some stay on top as 
  //supervisional master systems which have learned to reach closely to the limit of 1 
  //calculation for slave | master via asymptotic limit: use array of weighted values representing the economic output of each system, starting
  //with smallest value first, and biggest last... //need a threshold globalValue so the values representing each Props system can be sorted 
  //according to master or slave amidst the asymptotic limit




/** two types of invariant recognition:
  0: slow, patient ir-p-pr cycle recognition (a-to-a comparison until all a-to-b differences are met) [folding]
  1: fast, sparse cycle recognition of distinct features [->unfolding]
  **/

  /** additional notes: biological omissions are of neurotransmitter immitations since it is assumed that they are carries
      of nutrition; omissions of other quintessential biological immitations such as oxygen, nitrogen and carbon dioxide **/
	  
	  
	  
	  
  class globalFunctions {
	  /** asyptote: i.e. props have a value of their own numerical asymptote by means of having value, albeit by being
	  an asymptic value (numerically) they have the variable of uncertainty also numerically, i.e. e.g. as an irrational
	  number like pi or sq(2), e, ..., etc like energy with mass being energy of itself but with the addition of tacyon 
	  (future time) particles which overall and ultimately thus provide uncertainty to their numerical value (hence thus forth: asymptotic prop)
	  
	  _aw where a is the numerically (statisically*) random number which is acquired by a means of geometic randomness applied random_recursive onto
		itself for producing more randomness of itself in an out-of-order statistically number_format such as pi, e, (2)^2, ..., etc
		
		without a as a random variable, randomness could not substitute c of the e=mc^2 formula (solution) of matter, where iff e was of mass
		of itself applied to itself squared to produce mass (theroetical consideration of energy/potential formula**)
		
		*anything which, in and of itself, of this definition for asymptotic numbers, is by default asymptotic if it never endingly
		approaches infinite regarding its determinism/predictability (i.e. calculability)
		
		e.g. for instance, multiple universes couldn't exist; extra dimensions; anything which is beyond this current realm of reality could
		not possibly exist by any means (hence natural scientific agnostism)
		
		**_how many turtles down to calculate power consumption of prop activity (e.g. watts, ..., complex formula e.g. monetary cost)
			with this, as p, a prop is a prop p times itself to thus acquire physical (inactive) definition of itself: thus when applied with a,
			an energetic graviational asymptote can be formed discretely (how? what?)
	  */
	  public $globalMemory = array(); //new arrays for new instances... (e.g. perhaps many Props, i.e. systems of props utilizing this to exchange inputs and outputs, and to share memory between a master prop system)
	  public static $globalActiveNeo = 0; //this class is in use and thus active
	  public static $globalSetup = 0; //declares that this class is ready for use
	  
	  /**
		additional: priviledge properties e.g. register user/admin/etc of this class, restrictions on changes of globalFunctions 
		of asymptotes to prevent overriding definitions which are declared stable
	  **/
	  
	  function _construct($config=0) {
		  if($config!=1) {
			  if($this->globalSetup != 0) {
				  return true;
			  }
			  print "Error: $_GLOBALS[\"globalFunctions\"] has not been configured.  Please use $config[] in array form to setup this class.\n";
			return false; //exit?
		  while($config) {
			  if($config[]) {
				  //unrecognised format or such... then error out
			  }
			//$config["var"]=>"val", ...  
		  }
		  //config as global object (e.g. singularity: if global active neo, then end config iteration)
		} //we already have a config setup, so no need to return anything
	  }
	  
	  function isAsymotite($val, $_x, $_y) {
		  //check iff number_format
		
		  
	  }
	  
	  function newAsymptote(){}
	  
	  
	  
  }
  
  class props {
	  /** a system of props, hence Prop or props **/
	  
	  function test() {
		  //run a test on a prop system (technically referred to as Props)
	  }
	  
	  function newRelation() {} //similar and analogous to newProp, albeit maps relations between networks of props and individual props
	  
	  /**
		networking functions to define so multiple systems can symbiotically form solutions to larger scale problems
		//what if rather, with the slave->master asymptotic limit and threshold applied to establish an inherited order
		//of prop systems, each new generation encapsulates the previous... so structurally: electron->atom->cell per se 
			//thus, a broader scope of networking functions will be needed between the smallest singular prop p and highest
			//level in systemic complexity of a Props system (e.g. as an organism); as again, a limit, due to unknown vertical start/end positions
	  
	  
	  **/
	  
  }
  
  class prop {
	  //note: this only applies for a single prop definition
	  
	  /** 
	  Structural formation:
		a) props initialise with a single canvas image which is further divided into detailed segments 
		describing this image via relational props within this "canvas" network
	  
		b) these relational props of a network a can further divide and produce other detailed segments
		describing relational images
		
		c) using t variable for time differentiation from $_GLOBALS["T"], overlapping relations can be
		found and still be described as relational props (albeit tagged by a t var, between 0->1 (i.e. spatial or temporal))
		
		d) using v variable for vector differentiation of prop pr, two identical relations (spatial and/or temporal) can be
		stored as relational props (albeit tagged by v var of prop p)
		
	  Activity flow:
		note: supervision can be customised from 0->1
		initial flow is uncertain, stochastic, due to the asymptotic limit property of props when being trained for an exercise (solution), however
		this uncertainty eventually becomes less uncertain and the limit becomes increasingly more revealing of what the target is for the prop
		to reach: once the prop finds a way to relate input y=>x and the triggering polarity of y-gated input feed, it can then release a learned
		stable action potential for x | y=>x 
	  
		a) props can flow to/from (switch(p)) depending on the dominant handle/target currently being cycled in a prop network (X)
		b) if props are to resolve a target, they must learn to acquire the proper relational mappings such that p[y[...]]=>x
			//this requires props to be able to freely form relational connections either deterministically or probablistically
		c) SV is a property to resolve randomness by "free choice", but also produces an identity ID properties with its own
		   differentials psyches
		   i) activity flow states are always between UV and PV, valued as -1<->+1
		
	  Reinforcement properties:
		note: this can only occur via the property of SV
		
		a) error correction of invariant recognition, e.g. such as invalid details recognised from a relational prop canvas, are addressed
		by SV
		   i) eventually, automatic error correction is built up minimising the requirement of SV time to address an error detected (symbiotic feedback)
	  
	  
	  
	  Types of cycles (functional immitation: acronym reference): /** each have type of reward, connection, t etc all basic prop attributes **/
	/**	Thalamic (mode of i/o): T_x^g //central sensory relay component, will allow feedback to be passed to/from I/O of system and i/o of system depending on its modal state
		Pineal gland: P=SV //system agent with random output response to input; a limit for its response is provided to try and activate it
		Amygdala //emergency limit of input, e.g. will alarm entire prop system (brain) if there is something requiring emergency action
		Neocortical //auto modeling via r-to-r mappings 
		Basal Ganglia //central relational relay of prop rewards (folds, i.e. constructs a reward type (processing)) and unfolds (not processing, but active as a reward dispatch relay center)
		Pons //central power relay center: provides information of whether system is stable or overloading (custom functions for auto shutoff, etc)
		Medulla //a means to regulate temperature, fan speed, voltage, overclocks, ..., etc
		Cerebellum //automatically seeks to find balance of input as a central relay for this
		Hippocampus //systematic tree from the moment of input to the peak of system function (tree-like elevator)
		UV //props in active state of UV
		PV //ditto vice versa
		switch(UV, PV) //i.e. prop responsiveness to internal/external input (//depends on mode ternary argument of whether to increase/decrease activity by g)
	    _switch() //allows for serial execution of any cycle type by any given prop
		i/o+ top level flow of input/output (i.e. the flow of system i/o without entropy)
		i/o- low level flow of input/output (i.e. flow of system i/o with entropy (i.e. a thalamic drain is active))
		//ultimately, a central relay distributed means of Working Memory 
		/** each of these comprise their own prop nets **/
		
		
		//system foundation: /** rotational cycles **/
			//prop, a relational mechanism by which input can be related to other input
			//relation, ditto but for prop-to-prop with a switch(p) default mechanism to modify the flow of prop activity
			//attributes:
			//  - active, inactive (limits - inactive or memory) -- return invariant true or false
			//  - predictive (steps or limits)
			//  - learn (depth, limits) //i.e. learn something close and easy, or something far and hard
			//  - solve (y (relations, limits), x=limits) //find assemble of y to solve for limit of x
			//	where y (r, l) describes the permutations that are found by resource input y for prop p
			//  ...
			//component, a systemic relay and relational means constructed of a cycle function
		
	     
		 	  
	  function __construct($config) {
		  //seed or seeds (if recurrent)
		  if($config != array()) {
			  return false; //get error from ./sys_err.php
		  } else {
			  if(empty($config)) {
				  continue;
			  }
			  //else iterate configuration $config[]
			  return false; //just exit loop anyways
		  }
		  
	  }
	  
	  function newProp($i, $r, $p, $pr) { /** i = input[], r = relation,[] pr = propRelation[] arrays because relations are to be mapped**/
		  //creates $p = [$i->$r->$pr]
	  }
	  
	  function updateProp () { //CRUD (with exception of C, which is handled above^)
		  //ditto
	  }
	  
	  
  }
  
  
  
?>