class prop:
    
    """PV focuses SV onto reality via EV and UV focuses its isssues of PV via IV"""

    def prop():
        """CRUD methods"""
        self.properties = ["test","another"]; """list of properties key=>value pair where value is a href to qualia potential sequence"""
        self.focus = []; """SV or auto"""
        self.memory = []; """[EV=>PV]; [EV=>UV]; and ditto vice versa for IE memory types //perhaps set this as a def in itself"""

    def divideProp(prime, scale):
        pass

    """potential seeking, earning and sharing methods"""
    def budProp():
        """connects properties"""
        pass

    def debuddProp():
        """disconnects properties"""
        pass

    def inputProp():
        """nexus of prop input"""
        pass

    def netProps():
        """networks a ganglion of props together"""
        pass

    def chainProp():
        """adds to a net or a net learning to be found"""
        pass

    def chargePotential():
        pass

    def dischargePotential():
        pass

    def sharePropProperties(activation, propX, propY):
        pass

    
class conformer:

    def convolution1D():
        pass

    def convolution2D():
        pass

    def visionByTrans():
        pass

    def serialiseVisualPatch():
        pass

    def convolvePatch():
        pass

    def GANvarAutoEncoder():
        pass
    
class potential:

    """requires a hybrid transformer-convolution architecture, intertwined"""

    """lists the emotives for each available for use (actual ones available for scrappping and with their respective values"""
    vision = ["positive",[e+0, e-0],
              "negative",[e+0, e-0],
              "neutral",[e+0, e-0]];

    audio = ["positive",[e+0, e-0],
             "negative",[e+0, e-0],
             "neutral",[e+0, e-0]]

    text = ["positive",[e+0, e-0],
            "negative",[e+0, e-0],
            "neutral",[e+0, e-0]]

    def emotion():
        """note: use facebook, twitter, instagram, ..., etc for emotives"""
        pass

    def focusPatch():
        """transformer function"""
        pass

    def learnPatch():
        """learn features via convolution to n-th levels of patch from transformer input"""
        pass

    """data types"""
    def vision():
        """visual qualia (filter to convolve?)"""
        pass

    def audio():
        """audio qualia"""
        pass

    def text():
        """text qualia"""
        pass

    """prop functions"""
    def newProperty(propX,propY):
        """new connection (hrefToProperty reference X->Y mapping of recognition/responses)"""
        """note on mappings: one X->manyY and vice versa"""
        pass

    """note on potentials: they only reference to properties, not props since props are encapsulations like perceptrons"""

    
def href():
    """through various methods, allows access to any property, variable, constant, ..., quintessentials and superficial handle constructs instantaneously"""
    """key=>value pairs"""
    self.cls = []; """class"""
    self.clsProperty = [];
    self.clsFunc = [];
    self.href = []; """construct from the above"""
    """universal means for referencing classes, properties and other such definitions within an app"""

class SV:
    """perhaps a class instead: this is the RL class with efforted self-awareness"""
    loss = ["self",[], "immediate",[], "longTerm",[]];
    reward =  ["self",[], "immediate",[], "longTerm",[]];

    UV = [];
    PV = [];
    _self = []; """ID"""

    def focus():
        self.focus = ["self", ["self",[], "immediate",[], "longTerm",[]], "immediate", ["self",[], "immediate", [], "longTerm", []]];
        """immediate, short-term and long-term focus (requires PV and UV hrefs"""
        self.immediate = []; """immediate time-delay concerns: can range from 0.1ms to 1 day or longer"""
        self.moderate = []; """almost short-term like concerns"""
        self.longTerm = []; """eternal concerns"""
        pass
        
    def target():
        self.immediate = []; """immediate time-delay concerns: can range from 0.1ms to 1 day or longer"""
        self.moderate = []; """almost short-term like concerns"""
        self.longTerm = []; """eternal concerns"""

        self.target = []; """immediate, short-term, long-term"""
        self.target.feedback = []; """target feedback from recognition and response"""
        self.target.recognition = []; """relies on cycle, ..., etc to recognise the problem"""
        self.target.response = []; """ditto vice versa"""
        self.target.Ax = []; """parent target"""
        self.target.buds = []; """budding targets of e.g. friends, etc or a potential partner to produce a new prop from """
        pass

    self.experience = []; """experience matrix"""
    self.control = []; """control methods: requires control class for I/O i.e. text/audio/visual/.../etc motor functions""" 

class cycle:

    """each subtype has immediate, stm and ltm links"""
    skip = ["previous": 0, "current": n, "post": n+];
    step = x; """ditto"""
    turn = y; """ditto"""
    
    def votes():
        self.votes = [];"""activate prop through votes of similiar properties seen >50% similarity etc set"""

    def potential():
        """differential activation functions via potentials"""
        self.positive = 0;"""positive potential activation -- needs to be a global from potentials"""
        self.negative = 0;
        self.neutral = 0;

    def universal():
        """ID, PV, UV, SV -- this is the activation nexus of a prop and is unique to each and every prop/propnet/propsys"""
        self.PV = [];"""activate through PV threshold from PV connections through PV properties"""
        """activate from focus pathways"""

    """appending methods e.g. for properties"""
    def skip():
        pass

    def resume():
        pass

    def pause():
        pass

    def step():
        pass

    def turn():
        pass

    def rotate():
        """unsure if this is needed but must be sphearical"""
        pass
    

class memory:

    PV = []; """best state memory for both sleep and wakefulness (of e.g. solutions)"""
    UV = []; """universal memory (of e.g. solutions)"""
    ID = []; """memory of self (i.e. best state of motability)"""
    lastKnownState = [];
    expectedState = [];
    """qualia in memory context is/are the latent connective constants which result in reactivation of memory (some type of variational autoencoder stuffs required)"""
    """to-do: stimulting qualia to stimulate the production of potentials, even in memory or for active cycle X->Y solutions"""
    """compressive qualia triggered memory autoencoder"""
    
    def newFrame(frame1, frameN, depth, timeDelay, activation, qualia):
        """frames must come from another frame like props themselves: also note that frameN is polyrelational i.e. relates to more than one frame"""
        pass

    def frameByQualia():
        pass

    def frameByPotential():
        """complex chain of qualia"""
        pass

    def relateFrames(frame1,frame2, depth, timeDelay, activation):
        """via properties i.e. qualia/potential relation; depth is how many connections to route through to network the two frames; timeDelay is activation delay"""
        pass

    def updateFrameQualia():
        """feeling of memory to be updated"""
        pass

    def updateRelation(frameX, frameY):
        """updates memory also akin to a change memory function"""
        pass
    
    
